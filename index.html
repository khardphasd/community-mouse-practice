<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Click Practice</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        .game-target {
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .game-target:hover {
            transform: scale(1.03);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }
        .correct-feedback {
            animation: pulse-green 0.5s;
        }
        .incorrect-feedback {
            animation: shake-red 0.5s;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
        @keyframes shake-red {
            0%, 100% { transform: translateX(0); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-center justify-center">

    <div id="app" class="w-full max-w-4xl bg-white rounded-2xl shadow-2xl p-6 md:p-10 border-4 border-indigo-400">
        <h1 class="text-3xl md:text-4xl font-black text-center text-indigo-700 mb-2">
            Community Mouse Practice
        </h1>
        <p id="user-info" class="text-sm text-center text-gray-500 mb-6"></p>

        <!-- Game Container (Visible during play) -->
        <div id="game-container" class="space-y-6 hidden">
            <div class="bg-indigo-100 p-4 rounded-xl shadow-inner border-2 border-indigo-300">
                <p class="text-xl md:text-2xl font-bold text-indigo-800 text-center flex items-center justify-center space-x-2">
                    <span id="round-display">Round 1 / 10:</span> 
                    <span>Click the 
                        <span id="target-prompt" class="text-pink-600 font-extrabold underline">...</span>
                    </span>
                    <button id="speak-button" class="text-indigo-600 hover:text-indigo-800 transition duration-150 transform hover:scale-110 p-1 rounded-full bg-indigo-200 disabled:opacity-50 disabled:cursor-not-allowed" title="Repeat the prompt">
                        <!-- Speaker icon (SVG for better aesthetics) -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                            <path d="M11 5L6 9H2V15H6L11 19V5Z"></path>
                            <path d="M15.54 8.46a6.11 6.11 0 0 1 0 7.08"></path>
                            <path d="M19.07 4.93a10.68 10.68 0 0 1 0 14.14"></path>
                        </svg>
                    </button>
                </p>
            </div>

            <!-- Targets Grid -->
            <div id="target-grid" class="grid grid-cols-2 md:grid-cols-3 gap-4 md:gap-6 p-2 md:p-4 bg-gray-50 rounded-xl">
                <!-- Targets will be injected here -->
            </div>

            <!-- Stats and Feedback -->
            <div class="flex justify-around text-lg font-semibold text-center">
                <p class="text-green-600">Correct: <span id="correct-count">0</span></p>
                <p class="text-red-600">Incorrect: <span id="incorrect-count">0</span></p>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="text-center p-8">
            <p class="text-xl text-gray-700 mb-8">
                Ready to practice? We'll ask you to find the right community helper or place over 10 rounds. Listen for the instructions!
            </p>
            <button id="start-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg transition duration-300 transform hover:scale-105">
                Start Practice!
            </button>
        </div>

        <!-- Report Modal (Hidden by default) -->
        <div id="report-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-xl p-8 max-w-lg w-full shadow-2xl">
                <h2 class="text-3xl font-bold text-indigo-700 mb-4 text-center">Practice Complete!</h2>
                <p class="text-lg text-gray-700 mb-6 text-center">Great work! Here is your performance summary.</p>

                <div id="report-summary" class="bg-indigo-50 p-4 rounded-lg border border-indigo-200 mb-6 text-gray-800">
                    <p class="font-bold mb-2">Report Details:</p>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                        <li id="report-time"></li>
                        <li id="report-success"></li>
                        <li id="report-total-clicks"></li>
                    </ul>
                    <p class="font-bold mt-4 mb-1">Actionable Feedback:</p>
                    <p id="report-feedback" class="italic text-base"></p>
                </div>

                <div class="text-center">
                    <button id="email-button" class="w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-md transition duration-300">
                        Submit Data to Teacher's Sheet
                    </button>
                    <button id="restart-button" class="mt-4 w-full bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg text-lg shadow-md transition duration-300">
                        Start Over
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, collection, setDoc, serverTimestamp, getDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONSTANTS & INITIALIZATION ---
        const TARGET_ROUNDS = 10;
        const TARGET_DATA = [
            { id: 'fire-station', name: 'Fire Station', icon: 'üöí', color: 'red-500' },
            { id: 'police-station', name: 'Police Station', icon: 'üöì', color: 'blue-500' },
            { id: 'school', name: 'School', icon: 'üè´', color: 'green-500' },
            { id: 'hospital', name: 'Hospital', icon: 'üè•', color: 'purple-500' },
            { id: 'library', name: 'Library', icon: 'üìö', color: 'yellow-500' }
        ];

        // !!! FORM SUBMISSION CONFIGURATION - CORRECTED !!!
        // This is the submission endpoint for the user's Google Form.
        const FORM_SUBMISSION_URL = "https://docs.google.com/forms/d/e/1FAIpQLSf6QePrHAUAohHSiJ-qNtgGCy708J6LSZyOH35W7svaQ0YFyQ/formResponse"; 
        
        // These IDs are extracted directly from the user's pre-filled link.
        const FORM_FIELD_IDS = {
            userId: 'entry.1118925493',      // Correct ID for User ID
            timeSpent: 'entry.1759795426',   // Correct ID for Time Spent
            successRate: 'entry.164483531',  // Correct ID for Success Rate
            feedback: 'entry.505531947',     // Correct ID for Actionable Feedback
            improvement: 'entry.498032036',  // Correct ID for How to Improve
        };

        // Validation flags (should now pass)
        const FORM_URL_CHECKER = FORM_SUBMISSION_URL.includes("/formResponse"); 
        const IS_PLACEHOLDER_ID_USED = false; // Manually set to false as IDs are updated


        // --- FIREBASE SETUP ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;
        let userId = 'loading';

        // --- GAME STATE ---
        let gameState = {
            isAuthReady: false,
            isPlaying: false,
            round: 0,
            correctClicks: 0,
            incorrectClicks: 0,
            currentTarget: null,
            startTime: null,
            endTime: null,
            totalTargets: TARGET_ROUNDS
        };

        // --- DOM ELEMENTS ---
        const startScreen = document.getElementById('start-screen');
        const gameContainer = document.getElementById('game-container');
        const startButton = document.getElementById('start-button');
        const targetGrid = document.getElementById('target-grid');
        const targetPrompt = document.getElementById('target-prompt');
        const roundDisplay = document.getElementById('round-display');
        const correctCount = document.getElementById('correct-count');
        const incorrectCount = document.getElementById('incorrect-count');
        const reportModal = document.getElementById('report-modal');
        const reportTime = document.getElementById('report-time');
        const reportSuccess = document.getElementById('report-success');
        const reportTotalClicks = document.getElementById('report-total-clicks');
        const reportFeedback = document.getElementById('report-feedback');
        const emailButton = document.getElementById('email-button');
        const restartButton = document.getElementById('restart-button');
        const userInfo = document.getElementById('user-info');
        const speakButton = document.getElementById('speak-button');

        // --- TTS HELPER FUNCTIONS ---

        // Function to convert Base64 string to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Function to convert PCM audio data to WAV Blob
        function pcmToWav(pcmData, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);
            
            // Helper function to write bytes
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            
            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Sub-chunk 1 size (16 for PCM)
            view.setUint16(20, 1, true); // Audio format (1 for PCM)
            view.setUint16(22, 1, true); // Num channels (Mono)
            view.setUint32(24, sampleRate, true); // Sample rate
            view.setUint32(28, sampleRate * 2, true); // Byte rate (SampleRate * NumChannels * BitsPerSample/8)
            view.setUint16(32, 2, true); // Block align (NumChannels * BitsPerSample/8)
            view.setUint16(34, 16, true); // Bits per sample (16)
            
            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true); // Data size

            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true); // Signed 16-bit little-endian
                offset += 2;
            }
            
            return new Blob([view], { type: 'audio/wav' });
        }


        // --- TTS API FUNCTION ---

        async function speakPrompt(text) {
            speakButton.disabled = true;
            speakButton.classList.add('opacity-50', 'cursor-not-allowed');

            let retries = 0;
            const maxRetries = 3;
            let audioUrl = null;

            while (retries < maxRetries) {
                try {
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                    // Instruct the model to use a friendly, encouraging tone.
                    const prompt = `Say in a friendly, encouraging tone: "${text}"`;
                    
                    const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Kore" } // A firm, clear voice
                                }
                            }
                        },
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        // Extract sample rate from mimeType (e.g., audio/L16;rate=24000)
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000; 

                        // API returns signed PCM16 audio data.
                        const pcmBuffer = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmBuffer);
                        
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        audioUrl = URL.createObjectURL(wavBlob);
                        break; // Success
                    } else {
                        throw new Error("Invalid or missing audio data in response.");
                    }
                } catch (error) {
                    console.error(`TTS attempt ${retries + 1} failed:`, error);
                    retries++;
                    if (retries < maxRetries) {
                        const delay = Math.pow(2, retries) * 1000; // Exponential backoff
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }

            speakButton.disabled = false;
            speakButton.classList.remove('opacity-50', 'cursor-not-allowed');

            if (audioUrl) {
                const audio = new Audio(audioUrl);
                audio.play().catch(e => console.error("Error playing audio:", e));
                audio.onended = () => URL.revokeObjectURL(audioUrl); // Clean up the Blob URL
            } else {
                console.error("Failed to generate or play audio after multiple retries.");
            }
        }


        // --- FIREBASE FUNCTIONS ---

        async function initFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase config not available. Running in local mode.");
                gameState.isAuthReady = true;
                userId = crypto.randomUUID(); // Use a random ID for local mode
                userInfo.textContent = `User ID: ${userId} (Local Mode)`;
                return;
            }

            try {
                // setLogLevel('debug'); // Uncomment for detailed console logs
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        gameState.isAuthReady = true;
                        userInfo.textContent = `User ID: ${userId}`;
                        console.log("Firebase Auth Ready. User ID:", userId);
                    } else {
                        // Attempt to sign in
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });

                // Initial sign-in attempt if the listener hasn't fired yet
                if (!auth.currentUser) {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                }
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                // Fallback to anonymous auth state if initialization fails
                gameState.isAuthReady = true;
                userId = 'error-fallback';
                userInfo.textContent = `User ID: ${userId} (Auth Error)`;
            }
        }

        async function saveSessionData(data) {
            if (!db || !gameState.isAuthReady) {
                console.warn("Firestore not initialized or auth not ready. Data not saved.");
                return;
            }
            try {
                // Path: /artifacts/{appId}/users/{userId}/mouse_practice_sessions
                const collectionPath = `artifacts/${appId}/users/${userId}/mouse_practice_sessions`;
                const docRef = await addDoc(collection(db, collectionPath), {
                    ...data,
                    timestamp: serverTimestamp(),
                });
                console.log("Session saved with ID: ", docRef.id);
            } catch (error) {
                console.error("Error saving session data to Firestore:", error);
            }
        }

        // --- GAME CORE LOGIC ---

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function renderTargets(targets) {
            targetGrid.innerHTML = '';
            targets.forEach(item => {
                const targetEl = document.createElement('div');
                targetEl.id = item.id;
                targetEl.classList = `game-target bg-white p-6 rounded-xl shadow-lg border-4 border-gray-300 flex flex-col items-center justify-center text-center transition duration-150`;
                targetEl.innerHTML = `
                    <span class="text-6xl">${item.icon}</span>
                    <p class="mt-2 text-xl font-bold text-gray-700">${item.name}</p>
                `;
                targetEl.addEventListener('click', () => handleTargetClick(item.id));
                targetGrid.appendChild(targetEl);
            });
        }

        function startGame() {
            if (!gameState.isAuthReady) {
                console.warn("Authentication not ready yet. Please wait.");
                // Optionally show a loading message
                return;
            }

            // Reset state
            gameState.round = 0;
            gameState.correctClicks = 0;
            gameState.incorrectClicks = 0;
            gameState.startTime = new Date();
            gameState.isPlaying = true;
            gameState.currentTarget = null;
            gameState.endTime = null;

            // Hide start screen, show game
            startScreen.classList.add('hidden');
            reportModal.classList.add('hidden');
            gameContainer.classList.remove('hidden');

            updateGameUI();
            nextRound();
        }

        function nextRound() {
            gameState.round++;
            if (gameState.round > gameState.totalTargets) {
                endGame();
                return;
            }

            roundDisplay.textContent = `Round ${gameState.round} / ${gameState.totalTargets}:`;
            
            // Randomly select the target for this round
            const targetIndex = Math.floor(Math.random() * TARGET_DATA.length);
            gameState.currentTarget = TARGET_DATA[targetIndex].id;
            const targetName = TARGET_DATA[targetIndex].name;

            targetPrompt.textContent = targetName;
            // Note: The Tailwind classes here rely on the color being defined, e.g., 'text-red-500'
            targetPrompt.classList.value = `text-${TARGET_DATA[targetIndex].color} font-extrabold underline`;

            // NEW: Speak the prompt
            speakPrompt(`Click the ${targetName}`);

            // Shuffle and re-render the targets in the grid
            renderTargets(shuffle([...TARGET_DATA]));
        }

        function updateGameUI() {
            correctCount.textContent = gameState.correctClicks;
            incorrectCount.textContent = gameState.incorrectClicks;
        }

        function handleTargetClick(clickedId) {
            if (!gameState.isPlaying) return;

            const clickedEl = document.getElementById(clickedId);

            if (clickedId === gameState.currentTarget) {
                gameState.correctClicks++;
                // Visual Feedback for Correct
                clickedEl.classList.remove('border-gray-300', 'incorrect-feedback');
                clickedEl.classList.add('border-green-500', 'correct-feedback');
                
                setTimeout(() => {
                    clickedEl.classList.remove('border-green-500', 'correct-feedback');
                    clickedEl.classList.add('border-gray-300');
                    nextRound();
                }, 700);
            } else {
                gameState.incorrectClicks++;
                // Visual Feedback for Incorrect
                clickedEl.classList.remove('border-gray-300', 'correct-feedback');
                clickedEl.classList.add('border-red-500', 'incorrect-feedback');

                setTimeout(() => {
                    clickedEl.classList.remove('border-red-500', 'incorrect-feedback');
                    clickedEl.classList.add('border-gray-300');
                }, 700);
            }
            updateGameUI();
        }

        function generateFeedback(successRate) {
            if (successRate >= 90) {
                return {
                    message: "You did an AMAZING job! You quickly found almost every target. You have excellent mouse control! Keep practicing to maintain this mastery.",
                    improvement: "Try advanced clicking patterns or speed exercises next time. You are ready for new challenges!"
                };
            } else if (successRate >= 70) {
                return {
                    message: "Very good work! You found most of the targets successfully. A few clicks missed the mark, but your focus is strong. You have solid mouse control.",
                    improvement: "Focus on slowing down just a little bit to ensure 100% accuracy on every click. Think about where your mouse pointer is going before you click."
                };
            } else if (successRate >= 50) {
                return {
                    message: "Nice effort! You got about half the targets right. It looks like you're still building your confidence with the mouse, which is normal!",
                    improvement: "When the target appears, try pointing directly at the center of the picture before clicking. Practice clicking larger targets first, then move to smaller ones."
                };
            } else {
                return {
                    message: "Keep trying! You are just starting to learn where to point and click. Every session makes you better. You need more practice with basic pointing and clicking.",
                    improvement: "Try tracing the path from the prompt to the target very slowly with your mouse before you click. Focus on holding the mouse steady and clicking only once."
                };
            }
        }

        function endGame() {
            gameState.isPlaying = false;
            gameState.endTime = new Date();
            gameContainer.classList.add('hidden');
            reportModal.classList.remove('hidden');

            const timeSpentSeconds = Math.round((gameState.endTime - gameState.startTime) / 1000);
            const totalClicks = gameState.correctClicks + gameState.incorrectClicks;
            const successRate = totalClicks > 0 ? Math.round((gameState.correctClicks / totalClicks) * 100) : 0;
            
            const feedback = generateFeedback(successRate);
            
            // Prepare data for saving and reporting
            const sessionData = {
                userId: userId,
                totalTimeSpentSeconds: timeSpentSeconds,
                correctClicks: gameState.correctClicks,
                incorrectClicks: gameState.incorrectClicks,
                totalClicks: totalClicks,
                successRate: successRate,
                feedbackSummary: feedback.message,
                feedbackImprovement: feedback.improvement
            };

            // Display report in modal
            const minutes = Math.floor(timeSpentSeconds / 60);
            const seconds = timeSpentSeconds % 60;
            reportTime.textContent = `Time Spent: ${minutes}m ${seconds}s`;
            reportSuccess.textContent = `Success Rate: ${successRate}% (${gameState.correctClicks} correct)`;
            reportTotalClicks.textContent = `Total Clicks Attempted: ${totalClicks}`;
            reportFeedback.innerHTML = `
                <p class="font-semibold">${feedback.message}</p>
                <p class="mt-2 text-indigo-600">To Improve: ${feedback.improvement}</p>
            `;
            
            // Update email button link
            emailButton.onclick = () => submitFormReport(sessionData);

            // Save data to Firestore (non-blocking)
            saveSessionData(sessionData);
        }

        function submitFormReport(data) {
            // Check for both the correct URL format and whether the placeholder IDs have been replaced.
            if (!FORM_URL_CHECKER || IS_PLACEHOLDER_ID_USED) {
                console.error("FORM_SUBMISSION_URL or FORM_FIELD_IDS are set incorrectly. Please ensure the field IDs have been replaced using the steps provided.");
                document.getElementById('report-feedback').innerHTML = '<p class="text-red-600 font-bold">ERROR: Please tell the teacher to set up the correct Google Form submission link and REPLACE THE FIELD IDs in the code (see instructions in console)!</p>';
                return;
            }

            const timeString = `${Math.floor(data.totalTimeSpentSeconds / 60)}m ${data.totalTimeSpentSeconds % 60}s`;

            // Map data to the Google Form's entry IDs. 
            const formFields = {
                [FORM_FIELD_IDS.userId]: data.userId, 
                [FORM_FIELD_IDS.timeSpent]: timeString, 
                [FORM_FIELD_IDS.successRate]: `${data.successRate}% (${data.correctClicks} / ${gameState.totalTargets})`, 
                [FORM_FIELD_IDS.feedback]: data.feedbackSummary, 
                [FORM_FIELD_IDS.improvement]: data.feedbackImprovement, 
            };

            const params = new URLSearchParams();
            for (const key in formFields) {
                params.append(key, formFields[key]);
            }

            // Construct the pre-filled submission URL
            const finalFormLink = `${FORM_SUBMISSION_URL}?${params.toString()}`;
            
            console.log("Opening Google Form submission link:", finalFormLink);
            
            // Open the link in a new tab for easy submission
            window.open(finalFormLink, '_blank');
        }

        // --- EVENT LISTENERS ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        // Ensure the button listener uses the `submitFormReport` function with current session data
        emailButton.addEventListener('click', () => submitFormReport(gameState)); 
        
        speakButton.addEventListener('click', () => {
            // Re-trigger speech when the button is clicked
            const targetName = targetPrompt.textContent;
            if (targetName && gameState.isPlaying) {
                speakPrompt(`Click the ${targetName}`);
            }
        });

        // --- START APP ---
        window.onload = function() {
            initFirebase();
            // Initial rendering of targets on the start screen
            renderTargets(TARGET_DATA); 
        }

    </script>
</body>
</html>
